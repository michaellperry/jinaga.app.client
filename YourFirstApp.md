# Your First App

Your first Jinaga app will be in the public folder, so that anybody can access it without logging in.
You'll set up a connection to the back end, and then create view models to edit entities. You will
bind these to the view using KnockoutJS.

## Connect to the Back End

In the public folder, you created `myapp.js`. Open this again and create an instance of `Jinaga`. Sync
it with the distributor on the back end.

```JavaScript
var j = new Jinaga();
j.sync(new JinagaDistributor(distributorUrl));
```

The `distributorUrl` variable is defined in `config.js`, which is generated by the back end.

### Bind to synchronization status

Add some observables to your view model to keep track of synchronization status. The Jinaga Knockout
helper has a method to do that. Add this call to the MainViewModel constructor:

```JavaScript
jko.observeStatus(this);
```

Now bind those observables to the view. You will want to view the `status` and `error` properties:

```HTML
<div class="row">
  <div class="columns large-2"><span data-bind="text: status"></span></div>
  <div class="columns large-10"><span data-bind="text: error"></span></div>
</div>
```

With the back end running, refresh the page and see if the status message flashes. You can test the status
by stopping the back end. It should change to "Error". Start the back end again and the status will disappear.

## Root View Model

The main view model is for page-level properties. It doesn't contain domain information. Let's go down
one level and create a view model for the root of our domain. In this example, we will be talking about
a user group. First define a fact for the user group. Add this inside the MainViewModel constructor.

```JavaScript
var userGroup = {
  type: 'MyApp.UserGroup',
  identifier: 'papersdallas'
};
```

Then create a property of the main view model:

```JavaScript
this.userGroup = new UserGroupViewModel(userGroup);
```

### View model class

Below the MainViewModel function, you can define another function for the UserGroupViewModel constructor:

```JavaScript
function UserGroupViewModel(userGroup) {
}
```

## Collections

The root view model will have a collection of children. This is a collection of child view models, each one wrapping a child fact. In this example, the child fact represents a user group meeting. Let's create the facts.

### Child facts

Define a function that creates a child fact.

```JavaScript
function newMeeting(userGroup) {
  return {
    type: 'MyApp.Meeting',
    createdAt: new Date(),
    userGroup: userGroup
  };
}
```

The `createdAt` field distinguishes one meeting from another. Without it, there can be only one meeting in a user group.

Call the method from the view model and data bind it to a button:

```JavaScript
this.addMeeting = function () {
  j.fact(newMeeting(userGroup));
}
```

```HTML
<div data-bind="with: userGroup">
  <div class="row">
    <div class="columns large-3">
      <button class="button" data-bind="click: addMeeting">Add Meeting</button>
    </div>
  </div>
</div>
```

Refresh the browser and click the button. You should see a message on the server that the fact was received:

```
jinaga.distributor.server [30z7z] Received
  {"type":"MyApp.Meeting",
   "createdAt":"2016-10-30T18:11:29.555Z",
   "userGroup":{"id":2,"hash":2130125486}}
```

Now let's work on displaying that meeting.

### Child view model

Create another file called `meeting.js`. Add the `<script>` reference to the HTML file. This will contain your meeting view model:

```JavaScript
function MeetingViewModel(meeting) {
  this.title = meeting.createdAt;
}
```

We'll start with the created date as the title, just to see something on the screen. In a little bit, we'll replace that with the actual title.

Create a template function that matches meetings in a user group.

```JavaScript
function meetingsInUserGroup(userGroup) {
  return {
    type: 'MyApp.Meeting',
    userGroup: userGroup
  };
}
```

*More information on [template functions](https://github.com/michaellperry/jinaga/blob/master/TemplateFunctions.md).*

Add a `Collection` to the `UserGroupViewModel` for meetings matching this template. Call the `watch` function to start watching for these meetings:

```JavaScript
this.meetings = new jko.Collection(
  userGroup,
  [meetingsInUserGroup],
  MeetingViewModel);
this.meetings.watch();
```

*More information on [Collection](https://github.com/michaellperry/jinaga.app.client/blob/master/Collection.md).*

This will create a `MeetingViewModel` for each meeting in the user group. Now you can bind the `items` of this collection and see the meeting you just added.

```JavaScript
<div class="row" data-bind="foreach: meetings.items">
  <div class="columns large-12">
    <span data-bind="text: title"></span>
  </div>
</div>
```

Refresh the browser and see if your meeting appears. If so, click the button and see if a new one is added. If the meetings do not appear, check the following:

- The `Sending` log message appears in the Node console, indicating that you are watching the `Collection`.
- The error `Uncaught ReferenceError: Unable to process binding "foreach: function (){return meetings.items }"` does not appear in the browser console, indicating that your `foreach` binding is outside of the `with: userGroup` block.
- No other data binding errors appear in the browser console, indicating that you are not binding to `meetings.items`.

## Mutable properties

Now let's put the meeting topic in place. This is a mutable property, meaning that the user can change it over time. The properties of a meeting that we've defined so far (`type`, `createdAt`, and `userGroup`) are immutable, meaning that the user cannot change them.

Define the title as a mutable property inside of the MeetingViewModel constructor. Replace the current definition of `this.title` with the following:

```JavaScript
this.title = new jko.Mutable('MyApp.Meeting.Title', meeting, '');
```

*More information on [Mutable](https://github.com/michaellperry/jinaga.app.client/blob/master/Mutable.md).*

The first parameter is the type of the fact representing the mutable property's value. Use the convention
`Application.Entity.Property`.

The second parameter is the entity that has the property. In this case, it's the meeting.

The third parameter is the default value of the property. Use this to indicate the type of the property. Use `''` for strings, `0` for numbers, `{}` for objects, or 'null' for nullable objects.

### Watching mutable properties

Create a function to watch for facts matching the generated template functions. Define this on the `MeetingViewModel` prototype:

```JavaScript
MeetingViewModel.prototype.watch = function () {
  this.title.watch();
};
```

Call this function after you create the `MeetingViewModel` in the MainViewModel constructor:

```JavaScript
this.userGroup.watch();
```

### Binding to mutable properties

Back in the HTML, you'll want to bind to the `userGroup` property of the main view model. Then inside
of that block, bind to the `name` mutable property. The `value` sub-property gives you access to the
current value.

```HTML
<div data-bind="with: userGroup">
  <input type="text" data-bind="value: name.value">
</div>
```

Keep the back end running as you build the app. You can test it now by simply refreshing the page. Change
the user group's name, tab out, and refresh to see that it was persisted. Open the page in another browser,
and see that it updates on one browser when you change it in the other.

